*WTF can't I search for web browser bookmarks within folders? I want the full path!!! **DX≪***

# TODO
- [ ] Find The Compiler Book
- [x] Find The DSL Blogs
- [ ] **Formal Methods**
- [ ] Write a better web browser!!! **DX≪**

# They Should Just Make An Awesome Wiki
* [free-programming-books](https://github.com/EbookFoundation/free-programming-books)
* [coding-entertainment](https://github.com/krmaxwell/coding-entertainment) ([hackertainment.net](https://web.archive.org/web/20160110043620/http://hackertainment.net/))
* [awesome-competitive-programming](https://github.com/lnishan/awesome-competitive-programming)
* [awesome-deduction](https://github.com/Shyam-Has-Your-Anomaly-Mitigated/awesome-deduction) (I made this one!!! :D)

# [Synthetic](https://en.wikipedia.org/wiki/Synthetic_intelligence)/[Artificial](https://en.wikipedia.org/wiki/Artificial_intelligence) Intelligence & Automation
*Every"-thing" I type is some form of intelligence; even "Hello World!!! :D" programs.*

# [Formal Methods](https://en.wikipedia.org/wiki/Formal_methods)
*Every"-thing" can be explained in terms of mathematics ∵ mathematics is yet another language.*
* [Formal Methods Wiki](http://formalmethods.wikia.com/wiki/Formal_Methods_Wiki)
* [Formal verification](https://en.wikipedia.org/wiki/List_of_important_publications_in_theoretical_computer_science#Formal_verification) (Wiki)
* Formal Specification
	* https://en.wikipedia.org/wiki/Formal_methods#Specification_languages
	* https://en.wikipedia.org/wiki/Category:Formal_specification_languages
	* https://en.wikipedia.org/wiki/Formal_specification#Software_tools
* [Hardware description languages](https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Hardware_description_languages) (Wiki)

## "-thing"s…
* **Formal methods:**
	* Formal methods migrate [99.99%](https://xkcd.com/1161/) of bugs; the hand sanitiser of instructing computers/ETC…
	* ("Declaratively") avoids side-effects to reduce the mental stress of keeping the program in your head; recursion becomes usefully generalised tech that makes loops (which usually depend on side-effects) redundant.
	* Recursion avoids [OB1](https://youtu.be/C5HeRliZ0Ns?list=PL84A56BC7F4A1F852&t=4m48s), Kenobis? (I'm going to start querying "Kenobies?", instead of "OK?" & "Okay?" & "Right?" & "Left?" & "Up?" & "Down?" & "Back?" & "For?" & ETC; yet another "-thing"!!! :D ...I'll probably forget where I got it from, [but](https://youtu.be/mjy5eokIm3U?t=27m36s)...)
	* Conservative termination checking; does exactly that. (Ensures a program will halt, even though we haven't solved the halting problem; yet…)
		* Coq (Is not cock butt a male chicken? It's what I type when queried how to pronounce it...), Idris, Agda, ETC…
	* Type-level programming; perfect for Top Down Design (TDD; but not Test Driven Development…). (TDD means you don't write code you don't end up using; [Professor Sahami](https://youtu.be/KkMDCCdjyW8?list=PL84A56BC7F4A1F852&t=4m25s) taught me about [TDD](https://youtu.be/C5HeRliZ0Ns?list=PL84A56BC7F4A1F852&t=13m))
		* I like Haskell types because you can tell a parametric story c̄ them, and also include the types of parametric functions; [inceptionally](https://en.wikipedia.org/wiki/Inception).
	* **Formal mathematics:**
		* Lambda calculus divides bugs between implementation, and (dysfunctionally) parameterised "-thing"s; but the implementation can be formally verified against formal specification(s).
		* Functions [DOTADIW](https://en.wikipedia.org/wiki/Unix_philosophy#Do_One_Thing_and_Do_It_Well), for both input & output; but they can be lists, so...
	* **Formal logic:**
		* Prolog (predicate calculus? SHLIK/SHLYK; Shows How Little I/You Know…) migrates all of the bugs into the truthfulness of facts, and factual rules (as opposed to functional rules; but "they" like to remind me that I'm not to think of rules as being functional..."they" also like to remind me IDK how to format/ETC Lisp); empowering you to imagine falsified ℝealities from the [atom](https://en.wikipedia.org/wiki/Prolog_syntax_and_semantics#Data_types) up.
			* `are(Paradoxical_Contradictions /*[PC](https://en.wikipedia.org/wiki/Political_correctness)…[DTPC](https://en.wikipedia.org/wiki/Donald_Trump)*/, impossible) :- concept(impossible), illogical(Paradoxical_Contradictions). % true.`
	* **[Synthetic](https://en.wikipedia.org/wiki/Synthetic_intelligence)/[Artificial](https://en.wikipedia.org/wiki/Artificial_intelligence) Intelligence:**
		* **[Machine learning](https://youtu.be/R9OHn5ZF4Uo) VS TDD (Test Driven Development):**
			* I used to think of TDD as writing small quantities of instructions, and then testing, iteratively; rather than writing it all in one go, and attempting to resolve all the error messages in one fell swoop, iteratively.
			* Now I think TDD is writing a vague/loose test to pass, and then narrowing/whittling/carving/chiselling down the test, to pass it again; recursively, until the test is perfect (which never happens). This allows for employees to have some"-thing" to show higher ups, and is more productive in terms of production; at least we have some"-thing" to show for all the funding we put into it. But this can easily result in unfinished, and poorly designed, products/produce.
			* Machine learning does the same "-thing"; implementing the instructional algorithms is comparable c̄ machines learning by observation of database dumps.
			* I was going to compare TDD c̄ formal methods (specification), where TDD starts from the primatively mechanical level, and formal methods starts from the abstracted intelligent level; Prolog/Haskell/ETC paradigms start from abstraction, whereas Assembly/C/ETC starts from mechanisation... (I think I just did? The comparison...)
	* **[Big O Notation](https://youtu.be/wwIysnVmAUg) ([voyage](https://en.wiktionary.org/wiki/bon_voyage#French)):**
		* You should be able to compute it automatically, but also...
		* Why be concerned with efficiency?
		* It's better to be conerned with optimisation techniques.
		* You could know your algorithm is inefficient, but not know how to improve it, nor whether or not it can even be further improved.
		* I'd rather focus on the "how", rather than the "what".
		* static/dynamic code analysis, refactoring, ETC; can (be automatically) optimise(d) for us.
		* it's like in mathematics; you don't remember all the rules, instead you just feed it to a computer to poop out the symbolic representation of best possible optimisation. (I kind of regret taking that mathematical minor ∵ I feel it's a backwards way of doing "-thing"s; but so are paper-based programming exams! Why do I do better at those? I guess I just don't see the usefulness of memerising calculus when it can be programmed in...I probably would've done the same with the programming exams, had I been able to program them in for automation...)
		* **[EG](https://stackoverflow.com/a/22732174):**
			* `get_tempoℝæl_unit(Input, Output) :- get_time(T), stamp_date_time(T, D9, local), date_time_value(Input, D9, Output).`
			* Imagine this is used for `Input`s: `year`, `month`, `day`, `hour`, `minute`, `second`.
			* It would be optimal to parameterise `D9`, into `Input` as a list, from `get_time(T), stamp_date_time(T, D9, local)`.
				* `, Input = [Whatever_I_Cannot_Remember, D9]`
			* Furthermore, if you are performing this action for each event in say a calendar, it would be optimal to parameterise/factor it out completely.
			* Some"-thing" like that... (Could be automated ∵ `T` & `local` don't change...much; well, for the purposes...but that would be bad for tempoℝæl dependencies; which you might as well hand-optimise.)
			* I've decided on modal optimisation.
				* Also interactive optimisation that queries the user; do you want me to optimise (factor out) this tempoℝæl "-thing" (instruction)?
					* It could perform "code injection", and the commit will be "Shyam Has Your Anomaly Mitigated!!! :D".
			* Another "-thing" I wanted in Prolog was disabling warnings between two points; like commenting out warnings...
	* I do hourly [scrum](https://en.wikipedia.org/wiki/Stand-up_meeting#Three_Questions) meetings c̄ ...myself! :D
		* Shyam
		* Conducts
		* ℝælly
		* Useful
		* Meetings

*When I feel confident (fluent) in my ability to use FP/Haskell & LP/Prolog, I will probably move onto FLP/Curry (Haskell++ c̄ logic instead of classes) & FLOP/FLOOP/Mercury (O/OO is Object-oriented; as in classes, but logically); but there's Coq/ETC, and Shyamscript… (When I get around to it…)*

# [Metaprogramming](https://en.wikipedia.org/wiki/Metaprogramming)
*Every"-thing" that isn't ℝeal Computational Instructions, is metaprogramming; even ASM.*
* English
	* [Compilers](https://en.wikipedia.org/wiki/List_of_important_publications_in_computer_science#Compilers) (Wiki)
	* [Programming languages](https://en.wikipedia.org/wiki/List_of_important_publications_in_computer_science#Programming_languages) (Wiki)
	* [Want to Write a Compiler? Just Read These Two Papers.](http://prog21.dadgum.com/30.html)
	* [Five Questions About Language Design](http://www.paulgraham.com/langdes.html)
	* [createyourproglang.com](http://createyourproglang.com/)
	* [WikiHow](https://www.wikihow.com/Create-a-Programming-Language)
	* There's some links in [here](https://softwareengineering.stackexchange.com/questions/84278/how-do-i-create-my-own-programming-language-and-a-compiler-for-it), including some"-thing" about metacompilers/metamaths/METAETC
	* There's some links in [here](https://stackoverflow.com/questions/1669/learning-to-write-a-compiler), including a Big List of Resources
	* There's some links in [here](https://www.quora.com/How-does-one-create-a-programming-language); probably...
	* There's some links in [here](https://www.quora.com/How-do-I-write-a-simple-compiler); probably...
	* There's some links in [here](https://softwareengineering.stackexchange.com/questions/165543/how-to-write-a-very-basic-compiler); probably...
	* [So You Want To Write Your Own Language?](http://www.drdobbs.com/architecture-and-design/so-you-want-to-write-your-own-language/240165488)
	* [Let’s Build A Simple Interpreter.](https://ruslanspivak.com/lsbasi-part1/) (in 14 parts)
	* Jack Crenshaw:
		* [Let's Build a Compiler](https://compilers.iecc.com/crenshaw/) (in 16 parts)
		* [PDF](https://compilers.iecc.com/crenshaw/tutorfinal.pdf) (1988)
		* [PDF](https://www.stack.nl/~marcov/compiler.pdf) (2012)
	* [Why Programming Languages?](http://soft.vub.ac.be/~tvcutsem/whypls.html)
	* [PROGRAMMING LANGUAGES](http://strlen.com/programming-languages/) (I'm mostly interested in [LANGUAGE DESIGN OVERVIEW
](http://strlen.com/language-design-overview/))
	* Differential Execution:
		* [SO](https://stackoverflow.com/questions/371898/how-does-differential-execution-work)
		* [Wiki](https://en.wikipedia.org/wiki/User:MikeDunlavey/Difex_Article)
* [DSLs](https://en.wikipedia.org/wiki/Domain-specific_language)
	* [One-Day Compilers](http://venge.net/graydon/talks/mkc/html/index.html)
	* [compilertools.net](http://compilertools.net/)
	* Federico Tomassetti:
		* [The ANTLR mega tutorial](https://tomassetti.me/antlr-mega-tutorial/)
		* [68 Resources To Help You To Create Programming Languages](https://tomassetti.me/resources-create-programming-languages/)
		* [What are good books on best practices of the design of domain-specific languages (DSL)?](https://tomassetti.me/what-are-good-books-on-best-practices-of-the-design-of-domain-specific-languages-dsl/)
		* [The complete guide to (external) Domain Specific Languages](https://tomassetti.me/domain-specific-languages/)
		* [LEARNING TO BUILD LANGUAGES](https://tomassetti.me/learning-build-languages/)
		* [LEARNING TO PROCESS CODE](https://tomassetti.me/learning-process-code/)
		* [The Best Programming Languages for Each Situation](https://tomassetti.me/best-programming-languages/)
	* [Language workbench](https://en.wikipedia.org/wiki/Language_workbench) (Wiki)
	* Martin Fowler:
		* [Language Workbenches: The Killer-App for Domain Specific Languages?](https://www.martinfowler.com/articles/languageWorkbench.html)
		* [DomainSpecificLanguage](https://martinfowler.com/bliki/DomainSpecificLanguage.html)
		* [Domain Specific Languages](https://martinfowler.com/books/dsl.html) (Book)
		* [List of DSL Patterns](https://martinfowler.com/dslCatalog/)
		* [Catalog of Refactorings](https://refactoring.com/catalog/)
		* [Refactoring](https://refactoring.com) (Apparently there's a book?)
	* [I Wish We Used Domain Specific Languages (DSLs) More](http://adamjonrichardson.com/2015/07/26/i-wish-we-used-domain-specific-languages-dsls-more/)
	* [DSL development: 7 recommendations for Domain Specific Language design based on Domain-Driven Design](http://www.theenterprisearchitect.eu/blog/2009/05/06/dsl-development-7-recommendations-for-domain-specific-language-design-based-on-domain-driven-design/)
	* [DSL Engineering](http://web.archive.org/web/20150515072343/http://lowcoupling.com/dslengineering)
	* [Lambda the Ultimate](http://lambda-the-ultimate.org/classic/DSL.html)
	* [Domain Specific Language](http://wiki.c2.com/?DomainSpecificLanguage)
	* Antithetical:
		* [Stumbling Blocks For Domain Specific Languages](http://wiki.c2.com/?StumblingBlocksForDomainSpecificLanguages)
		* [UML vs. Domain-Specific Languages](http://www.methodsandtools.com/archive/archive.php?id=71)
		* [DSLs: Definitely a bad idea!](http://www.panopticoncentral.net/2009/01/26/dsls-definitely-a-bad-idea/)
* Assembly
	* [Creating a language using only assembly language](https://news.ycombinator.com/item?id=9699065)
* C
	* [Baby Steps to a C Compiler](http://www.wilfred.me.uk/blog/2014/08/27/baby-steps-to-a-c-compiler/)
	* [How I wrote a self-hosting C compiler in 40 days](https://www.sigbus.info/how-i-wrote-a-self-hosting-c-compiler-in-40-days.html)
	* [Build Your Own Lisp](http://www.buildyourownlisp.com/)
* C++
	* [I wrote a programming language. Here’s how you can, too.](https://medium.freecodecamp.org/the-programming-language-pipeline-91d3f449c919)
* Python
	* [Basic](https://www.youtube.com/playlist?list=PLBOh8f9FoHHiKx3ZCPxOZWUtZswrj2zI0)
	* [7 simple steps to implementing a programming language](http://kjetilvalle.com/posts/implement-a-programming-language.html) (Lisp)
* Lisp
	* [7 lines of code, 3 minutes: Implement a programming language from scratch](http://matt.might.net/articles/implementing-a-programming-language/)
	* Any good Lisp book will include implementing Prolog.
	* [Write Yourself a Haskell... in Lisp](https://news.ycombinator.com/item?id=5235589)
* Haskell
	* [Write Yourself a Scheme in 48 Hours](https://news.ycombinator.com/item?id=1378043)
	* [Write You A Scheme](https://www.wespiser.com/writings/wyas/home.html)
	* [Write You a Haskell](https://news.ycombinator.com/item?id=8838712)
* JavaScript
	* [How to implement a programming language in JavaScript](http://lisperator.net/pltut/)
	* [Let’s Build a Programming Language](https://hackernoon.com/lets-build-a-programming-language-2612349105c6)
	* [How to be a compiler](https://medium.com/@kosamari/how-to-be-a-compiler-make-a-compiler-with-javascript-4a8a13d473b4)
	* [Super Tiny Compiler](https://news.ycombinator.com/item?id=11395656)
* PHP
	* [Super Tiny Compiler](https://github.com/BafS/the-super-tiny-compiler-php)
* Java
	* [Create Your Own Programming Language](https://www.codeproject.com/Articles/50377/Create-Your-Own-Programming-Language)
* [BASIC](https://youtu.be/KkMDCCdjyW8?list=PL84A56BC7F4A1F852&t=2m30s)
	* [Write your own compiler in 24 hours by Phil Trelford](https://youtu.be/-E2tu3MqR24)
* &nbsp;
	* [Bootstrapping a simple compiler from nothing](https://web.archive.org/web/20160604035203/homepage.ntlworld.com/edmund.grimley-evans/bcompiler.html)
	* [Brainfuck](https://stackoverflow.com/a/8357989)

# [XD ETNs & ETC](http://www.breckyunits.com/)
* http://www.breckyunits.com/show-hn-programming-is-now-two-dimensional.html
	* https://news.ycombinator.com/item?id=14604269
	* https://www.reddit.com/r/programming/comments/6imeht/programming_is_now_twodimensional/
* http://www.breckyunits.com/the-flaw-in-lisp.html
	* https://www.reddit.com/r/programming/comments/6j1kzv/the_flaw_in_lisp/
	* https://news.ycombinator.com/item?id=14915425
* http://www.breckyunits.com/3-dimensional-source-code.html

*I'm just [a square](https://en.wikipedia.org/wiki/Template:Flatland)… (I think it's Pythonic Lisp; also 0D is a character, 1D is a line, 2D is multiline, 3D is multifile, 2D visual programming is a "-thing", and gotos/functions/lists/ETC are multidimensional.)*
