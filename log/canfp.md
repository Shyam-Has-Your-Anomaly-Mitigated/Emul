# Emul
*from https://canfp.slack.com/*

---

...

**2017-09-19**

...

**shyam.id.au**
<br>**11:16:49** I'm thinking about dropping Haskell (and Prolog) for Curry; it solves more than just the pronunciation problem! :smile:
<br>**11:21:08** It's basically Haskell++; but instead of a classic post-increment, it utilises a logical post-increment.

**shyam.id.au**
<br>**12:12:14** Would I be mistaken to compare lambda calculus with logic gates, and category theory with boolean algebra?
<br>**12:12:36** That's how I think of it...

**shyam.id.au**
<br>**12:26:05** But I think closures are goto statements for nested functions; so what do I know?

**shyam.id.au**
<br>**12:42:50** @jack How do you pronounce "data"? I'm thinking either "duh-tah", "day-tah", or "dat(a)"; like my name, "shyama", where you open your mouth after the 'm' for the silent 'a', instead of keeping it closed.

**shyam.id.au**
<br>**01:00:47** https://www.youtube.com/watch?v=7PCkvCPvDXk
<br>**01:01:03** She's singing about dat(a)bass.
<br>**01:05:12** It would be cool if we could get her to reboot the song with alternative lyrics, while wearing geeky/nerdy glasses...

**shyam.id.au**
<br>**01:26:22** I got her email...

...

**2017-09-20**

...

**shyam.id.au**
<br>**02:37:13** üí©
<br>**02:40:53** I'm between languages at the moment; I'm considering lisp ‚àµ I've read wonders about...something to do with metaprogramming...it can do "-thing"s to itself...or something magical; I cannot remember what it was...

**jack**
<br>**02:42:39** lisp does a lot of things right (homoiconicity is amazing) but I cannot live without a type system

...

**2017-09-27**

...

**shyam.id.au**
<br>**11:56:20** Dogs have four legs, not two; a logical contradiction.
<br>**11:57:28** Wikipedia has a "List of important publications in computer science" page (sublinked because of Slack), that has a "Programming languages" section, that has the wizard book, lambda papers, and comprehending monads; monads are burritos, right?

...

**shyam.id.au**
<br>**12:38:04** I was reading through the Wikipedia page I sublinked, and found something I mentioned previously about lisp; "LISP also has powerful features for manipulating LISP programs within the language"...does anyone know if that is unique to lisp? From what else I have read; DSL in lisp is comparable with metaprogramming in ruby.

...

**2017-09-29**

**shyam.id.au**
<br>**08:05:25** S-expressions is just set theory, right?

**shyam.id.au**
<br>**08:14:26** @jack ML is Lisp with types. (REF 2017-09-20T02:42:39)
<br>**08:16:31** Ocaml = CL
<br>**08:16:38** SML = Scheme
<br>**08:17:38** That's full of assumptions though primarily based on CLOS...

**~~yyyy~~**
<br>**08:20:50** I am not sure I see the connection between s-exprs and set theory, care to explain?

**shyam.id.au**
<br>**08:26:14** Let's just say I thought that explains all the parens?
<br>**08:27:48** (IRL it's based on a doodle, but IDK how to word it; have you read/watched Flatland?)
<br>**08:28:09** https://en.wikipedia.org/wiki/Template:Flatland

**shyam.id.au**
<br>**08:33:30** Logic gates is set theory, and I've already compared lambda calculus with logic gates. (REF 2017-09-19T12:12:14)
<br>**08:34:14** I guess it's just my attempt to connect all three as being the same "-thing"...
<br>**08:38:07** I wish there was a DOT equivalent for Euler diagrams...
<br>**08:39:31** It's all about backtracking?
<br>**08:40:51** Directional graph theory?

**shyam.id.au**
<br>**08:47:13** I've been demonising Java in the forums for my uni course that requires us to use it, but thewebsiteisdown; I think I wrote something about a comic, in the land of lisp, selling me on lisp.
<br>**08:47:19** http://landoflisp.com/
<br>**08:47:35** Just scroll half way down the page.
<br>**08:48:40** Does Haskell have the restart guild?
<br>**08:49:34** Hot hacking.

**shyam.id.au**
<br>**08:54:40** Owl lisp is purely functional...
<br>**08:56:02** But the land of lisp is common; IDK if owls can even restart...
<br>**08:56:22** (Owl = Scheme)
<br>**08:58:36** All we need to do is weigh down the bird with logical programming, and call it Emu Lisp; then it's like Lisp + Haskell/Curry/Prolog...

**shyam.id.au**
<br>**09:31:39** https://youtu.be/8oi12dCzHG4
<br>My cake has been a lie!
<br>Monads are purely dysfunctional excuses!
<br>Closures are purely an excuse to support goto statements!
<br>Currying is purely an excuse to support parametric multiplicity!
<br>Higher-order functions are purely an excuse to support function pointers!

**shyam.id.au**
<br>**09:51:31** Add types to Emu Lisp, and call it Emul; the L stands for Lisp, but the word sounds like ML (em-el).
<br>**09:54:47** You'll be able to emul-ate DSLs...

...

**shyam.id.au**
<br>**10:34:28** Ke(w)ll; is that in general, or is it `case x of`?
<br>**10:35:24** I wonder if it's possible to have a conversation purely with a programming language...

...

**2017-10-03**

**shyam.id.au**
<br>**04:29:16** I used to think https://coggle.it/ was a good "-thing" until I learned DOT; but I am unable to code Venn/Euler diagrams; at best, I can nest lightly coloured subgraphs/clusters...but that's not what this post is about; I was thinking along the lines of HADOT; as in HaTeX, and HaXml...

**shyam.id.au**
<br>**11:04:22** MY BRAIN HURTS!
<br>**11:04:23** https://github.com/Dobiasd/articles/blob/master/programming_language_learning_curves.md

...

**2017-10-06**
	
**shyam.id.au**
<br>**08:41:42** @~~xxxx~~ ‚Ñùeal Machine Instructions (bin/hex/oct/dec/tri/ter/etc) are homoiconic; Lisp Machines were binary, right?
<br>**08:42:03** Gives a new meaning to the word "homophobic"...

**shyam.id.au**
<br>**08:52:08** Wikipedia has a page on decimal computers, and the Russians pioneered ternary/trinary systems; I know this because I debated the inferiority of binary systems with my professors when I began my degree. I also attempted to justify the benefits of using bytes over integers for "small data" (only if it fits; that's what she said! LOL XD ROFLMAO ...lqtm), when I was doing Java. I still think I'm right for both arguments.

...

**2017-10-07**
	
**shyam.id.au**
<br>**07:05:29**
My argument for bytes was that they are stored as a byte in memory; independent of register dimensions ‚à¥ resulting in more efficient (observable) data transfers. And the reason why the Russians failed to bring base-3 systems to the main stream, is due to the university not taking computer science seriously at the time, as "The new university rector considered computer design a pseudo-science." ‚à¥ they lost their funding; although they attempted to continue their research from their dorm, it inevitably dissolved...reportedly, there were many people interested in acquiring these systems, but the cold war prevented any exportation. By all accounts, they were superior to the binary systems; not only being able to compress data into fewer digits, but also more efficient, cheaper, faster, ETC.
<br>**07:07:12** I think Lisp Machines would've stood a better chance if they weren't binary. (edited)

...

**2017-10-09**

...

**shyam.id.au**
<br>**08:51:25** Literate programming can be purely functional; "the quick brown fox jumped over the lazy dog"...I think that's a predicate? Unless we program in past-tense; to avoid bugs, we just assume it already happened successfully.

**shyam.id.au**
<br>**08:58:37** If the fox is data, and the dog is a register; it could describe the computation as a story...
<br>**08:59:10** https://en.wikipedia.org/wiki/Shakespeare_Programming_Language
<br>**09:00:59** Assembly could be preprocessed in a functional style...
<br>**09:01:34** I mean it already is...
<br>**09:02:00** But like more advanced functional programming features...
<br>**09:04:34** And purity..?

**shyam.id.au**
<br>**09:12:11** You don't need to change state; just compose() a "string" of INSTRUCTIONS for the computer to follow.
<br>**09:14:32** Problem solving becomes story telling.

**shyam.id.au**
<br>**09:21:25** Another way to do it is as an experiment; a list of dependable/stable/involatile ingredients, followed by a list of programmable/computable/calculable instructions, and concluding with expected/testable/verified results.
<br>**09:24:50** I disavow FTSE!

**shyam.id.au**
<br>**09:30:26** Conversely; I've just discovered Khal Drogo is an alien from the Pegasus Galaxy...

**shyam.id.au**
<br>**09:39:14** Haskell should be able to `do` inline assembly! (edited)

**~~xxxx~~**
<br>**11:03:57** ohai @shyam.id.au
http://wall.org/%7Elewis/2013/10/15/asm-monad.html
<br>**11:04:06** you need `mdo` for labels though

**shyam.id.au**
<br>**11:30:47** What about a preprocessor to extract the inline ASM, and assemble/compile seperately, before linking the object code? It could JIT the ASM for interpretation/REPL.

**shyam.id.au**
<br>**11:39:43** $ inline asm=orgasm src=ghc syntax0=/asm/ syntax1=/msa/ file=inline.hs

**~~xxxx~~**
<br>**11:41:26** someone (chakravaty?) did an inline objective-c quasiquoter

**shyam.id.au**
<br>**11:41:31** syntax0 can just be syntax, and syntax1 can be xatnys.
<br>**11:43:58** @~~xxxx~~ Was that for Haskell? (This is the first time I've been exposed to quasiquoting.)

**~~xxxx~~**
<br>**11:44:08** yes
<br>**11:44:28** found it
<br>**11:44:29** https://hackage.haskell.org/package/language-c-inline

**shyam.id.au**
<br>**01:26:12** Should it not be true | f(x) == x(f) ?

**~~xxxx~~**
<br>**01:28:18** ?
<br>**01:29:06** with pointers and the array sugar, I believe that it's true that `x[y] == *(x + y) == *(y + x) == y[x]`

**shyam.id.au**
<br>**01:29:29** (+) x y == (+) y x
<br>**01:31:52** Is there a term for declarative parameters?

**~~xxxx~~**
<br>**01:32:41** I don't understand what you are asking

**shyam.id.au**
<br>**01:33:39** (/) x y != (/) y x
<br>**01:34:00** That's imperative parameters.

**~~xxxx~~**
<br>**01:34:38** isn't this just commutativity?

**shyam.id.au**
<br>**01:35:42** Thanks! :slightly_smiling_face:
<br>**01:37:14** I wonder if it's possible to solve every problem commutatively...

**~~xxxx~~**
<br>**01:37:29** you've lost me there

**shyam.id.au**
<br>**01:38:59** Commutative Programming?

**~~xxxx~~**
<br>**01:41:00** programming only with commutative functions?

**shyam.id.au**
<br>**01:41:05** Yes.

**~~xxxx~~**
<br>**01:41:14** aren't you sunk as soon as you try to subtract anything?
<br>**01:41:49** you could define a difference operator `diff x y = abs $ x - y` but I don't think you'll get far

**shyam.id.au**
<br>**01:41:50** Subtraction is just the addition of negative numbers.

**~~xxxx~~**
<br>**01:42:05** comparisons?

**shyam.id.au**
<br>**01:42:20** (-) (-3) (3) == (-) (3) (-3)

**~~xxxx~~**
<br>**01:42:56** `s/(-)/(+)/g`?

**shyam.id.au**
<br>**01:43:14** Oh, yeah...
<br>**01:46:45** I'm sure division could be achieved...
<br>**01:48:55** Using an inverse function...
<br>**01:49:31** (*) x (invert y)
<br>**01:50:14** I can think of no problem that cannot be solved purely commutatively. (edited)
<br>**01:54:01** Purely Commutative Programming == Purely Declarative Programming

**~~xxxx~~**
<br>**01:54:38** comparisons?

**shyam.id.au**
<br>**01:55:03** EG?
<br>**01:56:17** Equality is already commutative...

**~~xxxx~~**
<br>**01:56:22** `(<) :: Ord a => a -> a -> Bool` (edited)

**shyam.id.au**
<br>**01:57:14** Inequality is also commutative...

**~~xxxx~~**
<br>**01:57:35** once you move from Eq to Ord you get stuck?

**shyam.id.au**
<br>**01:58:17** I'll solve this...
<br>**02:02:34** The inverse function can solve it.
<br>**02:02:51** With multiplication.
<br>**02:02:58** It's the same thing as division.

**~~zzzz~~**
<br>**02:03:21** what about situations where the inverse is very difficult?

**shyam.id.au**
<br>**02:03:42** EG?

**~~zzzz~~**
<br>**02:04:05** well, most of public crypto is built on these problems

**shyam.id.au**
<br>**02:06:20** (\*) x (invert y) == x/y | 0<x/y if y<x ‚àß x/y<0 if x<y
<br>**02:06:40** compare ((\*) x (invert y))

**~~zzzz~~**
<br>**02:06:41** s/0/1?

**shyam.id.au**
<br>**02:07:03** Oh, yeah...

**~~zzzz~~**
<br>**02:07:31** also that assumes positive numbers

**shyam.id.au**
<br>**02:08:03** Why won't it work for negative numbers?
<br>**02:08:19** invert() will produce an error for zero.
<br>**02:11:21** Hmm...there must be a way to do negative numbers!

**~~zzzz~~**
<br>**02:11:47** sure, I‚Äôm just pointing out those conditions aren‚Äôt sufficient for prove the conclusions you have

**shyam.id.au**
<br>**02:12:12** I'll solve this...
<br>**02:14:09** You could just use strings...

**~~zzzz~~**
<br>**02:14:22** I‚Äôm not going to program in PHP (edited)

**shyam.id.au**
<br>**02:15:37** I mean invert() could return a string that keeps the negative symbol with it's parameter.
<br>**02:17:59** invert y == [1, /, y]
<br>**02:18:49** I'll think of a ‚Ñùeal solution...
<br>**02:20:23** Could just `compare x (invert y)`...

**shyam.id.au**
<br>**02:25:54** Lazy optimisation for mathematical operations?

**shyam.id.au**
<br>**02:38:54** `precedence x` should work
<br>**02:39:36** `precedence (precedence y)` will give `y` higher precedence than `x`
<br>**02:42:26** Could use the same trick for lists/tuples/matrices/arrays/sequences/ETC...
<br>**02:42:49** Purely Declarative Programming FTW!!! :smile:
<br>**02:44:15** But my language will not support `precedence`...
<br>**02:45:41** I don't think the overhead from object-orientation is worth the convenience of such a feature.
<br>**02:48:56** `(==) x y` would be used for zero before `compare zero (invert nonzero)`
<br>**02:50:46** I mean, you wouldn't `compare` zero.
<br>**02:51:57** Unless you `compare x err`, and assume `err` is zero... (edited)
<br>**02:56:32** Zero & negatives are unsolved problems for comparison in the ‚Ñùealm of commutative programming...
<br>**02:57:57** `(==) 0 x`

**~~zzzz~~**
<br>**02:58:16** why is zero special?

**shyam.id.au**
<br>**02:59:04** `0/x==0` no matter what `x` is; and `x/0==undefined`.
<br>**03:02:26** If you know one parameter is zero, then the signage of the other parameter will be indicative of the comparison.
<br>**03:04:03** I guess `invert` and `compare` could `return err` if a parameter is zero.
<br>**03:05:10** Or `compare` can just do 2 posts ago if a parameter is zero.
<br>**03:05:51** In fact, it only needs to return the nonzero parameter.
<br>**03:07:29** So I guess zero isn't special afterall...
<br>**03:08:45**
```
compare 0 _ = _
compare _ 0 = _
```

**shyam.id.au**
<br>**03:13:58** Theoretically, if you concurrently add {-1,1} to an integer; eventually one of the recursive additions will reach zero.
<br>**03:17:00** Symbolics; I remember watching the guy who made WolframAlpha language (or one of them)...
<br>**03:18:56** `compare (x/y) = _`

**shyam.id.au**
<br>**03:31:13** `f (x+y) = _` should give `x‚àà{-1,1}`
<br>**03:31:50** Maybe as well be `x‚àà{false,true}`
<br>**03:32:26** `f 0 == err`
<br>**03:34:31** if both parameters are greater than zero; `compare x (invert y)` (`compare` could do this internally).
<br>**03:35:05** if both parameters are less than zero; `compare (-x) (invert (-y))`
<br>**03:35:26** No, it cannot be internal...
<br>**03:36:05** if the parameters are either side of zero; well I think it's obvious which is which...
<br>**03:36:40** `greater x y` will return the greatest value.
<br>**03:36:51** `lesser x y` will return the lowest value.
<br>**03:37:01** Then just `(==)` them.
<br>**03:38:42** Can prelude hacking influence pattern matching?

**~~zzzz~~**
<br>**03:38:58** huh?

**shyam.id.au**
<br>**03:40:12** `f (x/y) = _` to accept parameters like `3/0`
<br>**03:40:57** `f (x+y) = _` to subtract one from the parameter and name it `x`, with the remainder named `y`.
<br>**03:44:03** `f (x+y) = _` is actually bringing the parameter closer to zero...
<br>**03:46:00** This could work for values within a distance of 1 from zero; by recursing twice, before `(==)` both "heads".
<br>**03:46:43** `(==) (f x_0) (f f x_1)`

...

**shyam.id.au**
<br>**05:20:34** actually it must be `(==) (f x) (f f x)`
<br>**05:25:25** No, it's more like `(==) (head x) (head (tail x))`

...

**2017-12-14**

**shyam.id.au**
<br>**07:03:50** I just got into LCA'18! :smile:
<br>**07:03:56** https://linux.conf.au/programme/miniconfs/functional-programming/
<br>**07:07:50** I'm returning to Haskell! :smile:
<br>**07:07:52** https://www.wespiser.com/writings/wyas/home.html (edited)

**shyam.id.au**
<br>**07:14:26** I will write Ice Scheme in Haskell, and the World will scream for it.
<br>**07:14:46** https://news.ycombinator.com/item?id=5235589
<br>**07:16:17** Then I'll use Ice Scheme to write SHIT; the H stands for Haskell, because it's Shyams' Haskell Implementation Tech, or some"-thing"...
<br>**07:16:28** https://news.ycombinator.com/item?id=8838712
<br>**07:16:57** Then my SHIT will be self-hosted.
<br>**07:19:58** Then I'll talk about it at CanFP! :smile: (My first talk will be "SHIT"..)

**shyam.id.au**
<br>**08:07:10** It's way easier to parse languages if every"-thing" has spaces, but that isn't the reason shells space "-thing"s like `[ logic ]`; `[` is a command.
<br>**08:08:26** It's inconvenient for language users though; I'd rather compromise on the implementation, than the language itself.
<br>**08:10:32** EG: If there is no command `[condition]`, then try searching for a command starting with either the shortest/longest substring.
<br>**08:13:03** `[` should look for a trailing `]` in the last parameter.
<br>**08:17:29** Spacial programming is like parenthetical programming in Lisp.

...

**2018-01-08**

...

**adrianh**
<br>**22:11:15** speaking of BSides, I‚Äôm giving a talk there! I hope to do a follow-up talk at CanFP on how I implemented everything I‚Äôll talk about at BSides (it‚Äôll be in Haskell)

...

**2018-01-09**

...

**shyam.id.au**
<br>**09:24:02** What are you talking about?
<br>**09:24:10** @adrianh

**adrianh**
<br>**09:57:03** http://www.bsidesau.com.au/speakers.html#adrian

...

**2018-01-10**

...

**shyam.id.au**
<br>**01:28:45** @adrianh Did you use CCCs? Prolog can give you ‚ä• to T for free; IDK how to get the same "-thing" in Haskell though, without a second implementation...
<br>**01:32:08** `reverse` doesn't work the way I want it to...
<br>**01:34:46** Does anyone do natural language processing in Haskell? I can only imagine doing it in Prolog for bidirectional translation...

**shyam.id.au**
<br>**01:54:36** Prolog VS Self-hosted programming language implementations; one automatically gives you disassembler/decompiler/ETC, and the other proves the language is actually useful/worthy/ETC...
<br>**01:59:26** A virtual/abstract machine language could be the middle man for Prolog translation, but optimised in some other language; Prolog facts/rules make a lot of sense for optimisation...

**shyam.id.au**
<br>**02:34:29** `(a -> b) -> (b -> a)`

**shyam.id.au**
<br>**02:52:09** `b` is for binary, `a` is for abstraction.

...

**2018-05-02**

...

#random

**shyam.id.au**
<br>**15:21:51** So CCCs are limited by the evaluation strategy?

**shyam.id.au**
<br>**15:56:44** How do you categorise evaluation strategies?

...

**2018-05-03**

...

#random

shyam.id.au [9:17 PM]
<br>Map is the "what to do", and (lazy) for each loops are the "how to do". (edited)
<br>I wish there were animated visual representations of (higher-order) functions; like they do for comparing sorting algorithm efficiencies, and other such "-thing"s...
<br>And not just the old classic "into the black box abstraction", and "out of the black box abstraction"; I mean to properly introduce each new generation of matryoshka dolls.
<br>More like some"-thing" you'd want to wear 3D goggles for...
<br>I want to be put inside of the function, so that I can ob1 (oh become one) with it...
<br>`visualise :: f -> gif`

shyam.id.au [9:40 PM]
<br>I also want to be able to observe, by a process of total immersion, the interconnectedness of all "-thing"s & their possibilities (like traversing the tree of functional life-forms); including the type system, evaluation strategy, ETC.

...

**2018-05-04**

...

#random

shyam.id.au [11:44 AM]
<br>Apparently, linux started out as a trivial program that would switch between printing AAAA and BBBB; `rev` that, implement `sh`, and you have bash...

...

#random

shyam.id.au [2:10 PM]
<br>I guess you could start cÃÑ a "Hello World!!! :D" program, and end up with a chatbot...
<br>By one way, or another; http://www.commitstrip.com/en/2018/03/01/interns-and-apis/

...

shyam.id.au [2:23 PM]
<br>Due to particle entanglement; you kick one tyre, you kick them all...

...

shyam.id.au [2:25 PM]
<br>Each an every particle is probably entangled cÃÑ some other object in this ‚Ñùeality; if you kicked object A, which is particularly entangled cÃÑ object B, does it count as kicking all the particles out of object B, superpositioningly?

...

**2018-05-15**

...

#random

shyam.id.au [9:57 PM]
<br>Assumption: All of technology is compromised.
<br>Query: Is it possible to use compromised technology to build new technology that is uncompromised?

...

#random

shyam.id.au [10:02 PM]
<br>I was thinking more along the lines of using SBCs to manufacture hardware, but I think I can see how they are two sides of the same coin; I just find it more difficult to deal cÃÑ software ‚àµ software is mutable, whereas hardware isn't.
<br>I'm thinking about using like a ‚Ñùeally long lever, or some"-thing", to control the laser that'll cut the filter at the nanometer level; for an IC...
<br>But I think I need a clean room to avoid side effects; I'm thinking magnetic ceiling would avoid falling debris, and a vacuum would repel any other types of bugs...
<br>I could use SBCs hooked up to sensors that DOTADIW; if it receives binary input, how could it possibly know the semantics?
<br>Rube Goldberg machines provide additional ‚ÑÇomplexity to attempt to implement a one-way function, of sorts... (edited)
<br>In my computer, I do not trust.
<br>(Even if it was formally verified, nor open sourced.) (edited)

...

**2018-05-20**

...

#random

shyam.id.au [1:08 AM]
<br>https://youtu.be/zzNgEsLsHgE
<br>I find that more motivational ‚àµ he does the challenge when it suits him (on a hot day), and he says "let's do it" (implying help, probably from an imaginary friend; Bert, and Ernie, have an unimaginary little yellow rubber friend).
<br>shyam.id.au [1:17 AM]
<br>Solid-state technology is inanimate, but (theoretically) can be artificially/synthetically intelligent ‚à¥ it's not a bad idea to befriend inanimate objects; practice makes perfect, and it's preferable to be on the winning side.
<br>Technically "inanimate" objects are ‚Ñùeally animated at the atomic/quantum/ETC level anyway, and they're particularly entangled cÃÑ every"-thing" else in this ‚Ñùeality too (interconnectedness of all "-thing"s). (edited)
<br>üï¥ Shoe phone!!! :D
<br>FVEY probably uses quantum entanglement to spy on every"-thing"...
<br>shyam.id.au [1:32 AM]
<br>I'm not sure, but I think entanglement only happens at high speeds; the double slit experiment indicates they avoid collisions at lower speeds...
<br>Which would mean the big bang has me entangled all over this ‚Ñùeality!!! :D
<br>shyam.id.au [7:07 PM]
<br>Stop hitting yourself!!! :D (...ow)

...

**2018-05-25**

...

#random

shyam.id.au [10:00 PM]
<br>How do you teach/hack an intelligence that can handle snakes & ladders? To figure out that skipping is a bad move.
<br>I have this faint idea, but I'm not sure how to access it; my brain has the neuro bridges under repair/construction...

...

**2018-06-01**

...

#random

shyam.id.au [6:31 PM]
<br>Does intelligence exist to do this? https://www.youtube.com/watch?v=mmkCS5eA4f8
<br>shyam.id.au [6:41 PM]
<br>In snakes & ladders, even if you have a precomputed list of dice rolls (to remove bias) rolled by a dedicated dice roller (for the sake of probability), that are unkown to the players; I think the gamblers' fallacy makes it a bad decision to skip, even if the probability is higher for the dice roll that lands you on a snake head. (Also; the probability may be against you, but it's ‚Öô.)
<br>shyam.id.au [6:47 PM]
<br>Balanced dice, and tempo‚Ñù√¶lly regulated dice rolls by a hypnotised roller cÃÑout disorderly influence.

...

---
