8< the file is a dexable jñānabox >8

8<
	version
	,[,calendar,format<0>]
	🤞
>8
,[,"HE",12018,11,06]

8<
	trimūrti
	,[,brahmā,viṣṇu,śiva,STR,ESC]
	viṣṇu
	,[,initiator,terminator]
	0 is 0ptional
	¬0 is ¬0ptional
	could have more than one to choose from
>8
,[,"[",[,[,3,",",";"],[,0,""]],"]","\"","\\"]

8< need to describe the language... >8
, [
	8< language >8
	"English"

	8< lowercase >8
	,["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","n","z"]

	8< uppercase >8
	,["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","N","Z"]
	
	8< othercase >8
	,[,"ā"]

	8< punctuation >8
	,[,"$"," "]
	
	8< adverbs >8
	
	8< verbs >8
	
	8< pronounds >8
	
	8< nouns >8
	
	8< noobnouns >8
	
	8< adjectives >8
	
	8< jectives >8
	
	8< probably going to have to learn phonetics/ETC... >8
]

8< mathematics >8
, [
	8< numbers/base >8
	,[,"श्याम","0","1","2","3","4","5","6","7","8","9"]
	
	8< operators; the decimal point is a fractional operation, right? (and some"-thing" in lambda calculus) >8
	,[,"λ",".",".","+","-","±","∓","×","÷","⟌","√","∂","∫"]
	
	8< constants >8
	, [
		8< https://youtu.be/bFNjA9LOPsg >8
		,[,"π","3.2"]
		,[,"τ","2⟌π"]
	]
]

8< barewords (to be preprocessed) >8
, [
	8< characters/strings/symbols/glyphs/ETC >8
	,[,mahāmantra<3><2,3,4>]
	
	8< actual barewords >8
	,[,a,b]
]

8<
	mantras
	the 1ˢᵗ nāma is for the file (if it's used here, it means here; if it's used there, it means there)
	the 2ⁿᵈ nāma is for the program counter
	the rest is for preprocessors/libraries/ETC
	there needs to be another box for chanting premantras/metamantras/ETC
>8
,[,"mahāmantra","dex",[,"scissors",".../metamantra_comments.box"]]

8<
	instruction sets
	use the @mantra to get the namespace for the positional
	use the #mantra to get the parameter list c̄ the first outdex
	barewords can probably just be preprocessed
	probably have @ & # mixed up
	@("mov") will return mov
	#(mov) will return "mov"
	
	instruction sets are for a specific computer; EG binary...like there is only one solution for each instruction
	so whatever ,mov(,a,b) corresponds c̄ should be all that there is ∴ hard-coded
	
	the idea is to be able to translate between instruction sets, and intelligently generalise optimisation
>8
, [
	, [
		,"instruction_set_name_for_assembler_and_compiler_and_optimiser_but_still_need_some_way_to_describe_each_mantra"
		8< each instruction is boxed separately >8
		,[,mov(,a,b),[,@("mov")_2,b_2,a_2]]
		8< this should be redundant/inferred; but I guess that would be .hex & .bin & .ETC files, or a mantra >8
		,[,[,@("mov")_16,b_16,a_16],[,@("mov")_2,b_2,a_2]]
		8<
			I guess cross-processing binary from trinary would be a trinary file, so the base can be any"-thing"
			2,2,2 = 3,3 ...when is a power of A equal to a power of B?
			2,2 = 4
			2,2,2,2 = 16
		>8
	]
	, [
		,"Shyamscript"
		,[.[].[]]
		,[,[],[]]
		,[;[];[]]
		,[:[]:[]]
		,[∴[]∴[]]
		,[∵[]∵[]]
	]
	, ["trimūrti",[,[],[]],[;[];[]]]
]
