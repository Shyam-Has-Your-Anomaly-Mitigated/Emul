8< the file is a dexable jÃ±Änabox >8

8<
	version
	,[,calendar,format<0>]
	ğŸ¤
>8
,[,"HE",12018,11,06]

8<
	trimÅ«rti
	,[,brahmÄ,viá¹£á¹‡u,Å›iva,STR,ESC]
	viá¹£á¹‡u
	,[,initiator,terminator]
	0 is 0ptional
	Â¬0 is Â¬0ptional
	could have more than one to choose from
>8
,[,"[",[,[,3,",",";"],[,0,""]],"]","\"","\\"]

8< need to describe the language... >8
, [
	8< language >8
	"English"

	8< lowercase >8
	,["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","n","z"]

	8< uppercase >8
	,["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","N","Z"]
	
	8< othercase >8
	,[,"Ä"]

	8< punctuation >8
	,[,"$"," "]
	
	8< adverbs >8
	
	8< verbs >8
	
	8< pronounds >8
	
	8< nouns >8
	
	8< noobnouns >8
	
	8< adjectives >8
	
	8< jectives >8
	
	8< probably going to have to learn phonetics/ETC... >8
]

8< mathematics >8
, [
	8< numbers/base >8
	,[,"à¤¶à¥à¤¯à¤¾à¤®","0","1","2","3","4","5","6","7","8","9"]
	
	8< operators; the decimal point is a fractional operation, right? (and some"-thing" in lambda calculus) >8
	,[,"Î»",".",".","+","-","Â±","âˆ“","Ã—","Ã·","âŸŒ","âˆš","âˆ‚","âˆ«"]
	
	8< constants >8
	, [
		8< https://youtu.be/bFNjA9LOPsg >8
		,[,"Ï€","3.2"]
		,[,"Ï„","2âŸŒÏ€"]
	]
]

8< barewords (to be preprocessed) >8
, [
	8< characters/strings/symbols/glyphs/ETC >8
	,[,mahÄmantra<3><2,3,4>]
	
	8< actual barewords >8
	,[,a,b]
]

8<
	mantras
	the 1Ë¢áµ— nÄma is for the file (if it's used here, it means here; if it's used there, it means there)
	the 2â¿áµˆ nÄma is for the program counter
	the rest is for preprocessors/libraries/ETC
	there needs to be another box for chanting premantras/metamantras/ETC
>8
,[,"mahÄmantra","dex",[,"scissors",".../metamantra_comments.box"]]

8<
	instruction sets
	use the @mantra to get the namespace for the positional
	use the #mantra to get the parameter list cÌ„ the first outdex
	barewords can probably just be preprocessed
	probably have @ & # mixed up
	@("mov") will return mov
	#(mov) will return "mov"
	
	instruction sets are for a specific computer; EG binary...like there is only one solution for each instruction
	so whatever ,mov(,a,b) corresponds cÌ„ should be all that there is âˆ´ hard-coded
	
	the idea is to be able to translate between instruction sets, and intelligently generalise optimisation
>8
, [
	, [
		,"instruction_set_name_for_assembler_and_compiler_and_optimiser_but_still_need_some_way_to_describe_each_mantra"
		8< each instruction is boxed separately >8
		,[,mov(,a,b),[,@("mov")_2,b_2,a_2]]
		8< this should be redundant/inferred; but I guess that would be .hex & .bin & .ETC files, or a mantra >8
		,[,[,@("mov")_16,b_16,a_16],[,@("mov")_2,b_2,a_2]]
		8<
			I guess cross-processing binary from trinary would be a trinary file, so the base can be any"-thing"
			2,2,2 = 3,3 ...when is a power of A equal to a power of B?
			2,2 = 4
			2,2,2,2 = 16
		>8
	]
	, [
		,"Shyamscript"
		,[.[].[]]
		,[,[],[]]
		,[;[];[]]
		,[:[]:[]]
		,[âˆ´[]âˆ´[]]
		,[âˆµ[]âˆµ[]]
	]
	, ["trimÅ«rti",[,[],[]],[;[];[]]]
]
