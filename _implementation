i was going to make it a command-line option…
just run the optimised implementation first, and run user-friendly versions if it fails
if they fucked up, then they can pay the temporal price, and play the waiting game
or use a better editor
user-friendly are "-thing"s like; you fucked up somewhere between [x,y] on line z
[x,y] is interval notation, but what about coordinate notation?
combine them for; you fucked up somewhere between [(a,y),(b,y)], where y is now the vertical line number
lets just abuse mathematics to insult innumerates; ∃[(a,y),(b,y)]⊆F→err_msg
err_msg∈{⊥,λx.∞,..}
F = file address

 ╱
╳ ╔══════════════════════════════════════╗
╳ ║ from now on                          ║
╳ ║ this is how i will use irc           ║
╳ ║ vim makes it as easy as              ║
╳ ║ Roverwritefollowedbyspace\e          ║
╳ ╚══════════════════════════════════════╝
 ╲

 ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
┊ i also like this ┊
 ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈

canfp.slack.com
`(= lisp functional_programming) ∧ (= lisp unsafe) → (= functional_programming informal)`
`(= formal safe) ∧ (= haskell safe) → (= haskell formal)`
I'm the man in the middle!!! :D

##prolog
i prefer reversibility over optimisation
i feel like optimisation at such high levels of abstraction is considered value drift
https://universalpaperclips.gamepedia.com/Value_Drift
i value the perfection of prolog over the heuristics of haskell (for my personal life)
prolog is basically a bruteforce language and bruteforce is the slowest but guaranteed
/me wonders if irc supports ansi escaping
 ╱
╳ ╔═════════════════════════╗
╳ ║ we need more expressive ║        
╳ ║ communication standards ║        
╳ ╚═════════════════════════╝
 ╲
depth search is discovering the first satisfying leaf or node one at a time and breadth search is the superpositional exploration of all possibilities?
	yes
/me wonders if this is what everyone means when they say they are doing time or they did their time
/me never wants to do time ever again after this

naming convention (you can think of arguments as facts of the clause)
…lists are good for definite clause grammars
…lists are good for F(X) instead of F(A), F(A,B), F(A,B,C),..
'arg 0'([[],[]]).
'arg 1'([[ARG1],[]]).
'arg 1, arg 2'([[ARG1, ARG2],[]]).
'arg 1, arg 2, arg 3'([[ARG1, ARG2, ARG3],[]]).
…unless the arguments share "-thing"s in common; why should the order matter?
property([[H|T], []]).
commonality([[H|T], []]).

coding convention
f([I,O]) :- true
	, I = [H|T]
	, O = [_|_]
	, I = Q
	, O = A
	, g([H, O])
	, f([T, O])
	, ( true
		, zero([[],[]])
		; alt([I, O])
	)
	; err([[f([I, O])], E])
	, E = []
	.

knowledge base systems

%propositional_knowledge_base
'i have a lot of junk'.
'i do not have a job'.

%royal_knowledge_base
'i am dieting'.
'i am exercising'.
'i am getting healthy' :- 'i am dieting', 'i am exercising'.
'i am getting unhealthy' :- 'i am not dieting'; 'i am not exercising'.

%factual_knowledge_base
recipe(['thrown vegvit multivitamin']).
recipe(['peeled fresh orange']).
recipe(['peeled fresh banana']).
recipe(['peeled fresh avocado']).
recipe(['spreaded bread']).
recipe(['serialised vegan milk']).
recipe([
	'stirred rice cooker'
	, 'purified water filter'
	, 'bubbling water kettle'
	, 'poured flaxseed oil'
	, 'torn fresh chilli'
	, 'tipped cup of rice'
	, 'circumfused can of tomato dye'
	, 'spilled can of corn kernels'
	, 'decanted can of red kidney beans'
	, 'sprinked iodised salt'
	, 'spouted water'
	, 'scraped fresh avocado'
]).
recipe([
	'stirred rice cooker'
	, 'purified water filter'
	, 'bubbling water kettle'
	, 'poured flaxseed oil'
	, 'torn fresh chilli'
	, 'tipped cup of rice'
	, 'circumfused can of tomato dye'
	, 'spilled can of corn kernels'
	, 'decanted can of red kidney beans'
	, 'sprinked iodised salt'
	, 'spouted water'
	, 'tossed vegan cheese'
	, 'scraped fresh avocado'
	, 'spooned vegan sour cream'
]).

%tabular_knowledge_base
tab1(X) :- findall(E, row1(E), X).
row1(X) :- X = col1_col2_col3_col4_col5(_), X.
col1_col2_col3_col4_col5([COL1, COL2, COL3, COL4, COL5]).

dcg rules

get --> [X], {f(X)}.
f --> [X], {g(X)}.
f --> [H|T], {h(H),t(T)}.
f --> L, {lisp(L)}.
f --> [A,B,C], {google([A,B,C])}.

% a plan is basically just a list of things to do

% foreflow/backflow
f(Y) -> [X], {f(X,Y)}. % f/3 --> f/2
% backflow/foreflow
f --> [X], {f(X)}. % f/2 --> f/1

homoiconic graph theory

[terms]
 ├─────────────────────────────────┐
[simple terms]                    [complex terms]
 ├──────────────────────┐          │
[constants]             │         [compound terms]
 ├───────────────┐      │          │
[numbers]        │      │          │
 ├────────┐      │      │          │
[integer][float][atoms][variables][terms]

machine simulation idea

[small memory]
 └└└└└└└└└└└└──────────────────────┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐
                                  [big memory big memory]
[010110101101]
 └└└└└└└└└└└└──────────────────────┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐
                                  [110101000101101110101]

repeating corners are animation spaces

┌─┐        ┌           ┐
 0 ┐       │ 0 1 1 0 1 │
 1 ┤       └ ┊ ┊ ┊ ┊ ┊ ┘
 1 ┼─────────┼─┼─┼─┼─┼
 0 ┤       ┌ ┊ ┊ ┊ ┊ ┊ ┐
 1 ┘       │ 1 0 1 1 0 │
└─┘        └           ┘

i want to be able see the flow chart like the symbolic movements of the matrix

frame 0: [a]────────[?]
frame 0: [a]────────[_]
frame 0: [a]────────[b]
frame 1: [a]a───────[b]
frame 2: [a]─a──────[b]
frame 3: [a]──a─────[b]
frame 4: [a]───a────[b]
frame 5: [a]────a───[b]
frame 6: [a]─────a──[b]
frame 7: [a]──────a─[b]
frame 8: [a]───────a[b]
frame 9: [a]────────[a]

signal transmission

frame 0: [a]───────╼[?]
frame 0: [a]╾───────[?]

directional signal transmission (goto heavy weight)

frame 0: [a]────────[?]

bidirectional signal transmission (so light it can goto any key)
http://ars.userfriendly.org/cartoons/?id=20030128

     ┌─┐
[x]──┤f├─────[y]
     └─┘

blackbox functionality and differing distances for complexity theorists

     ┌───┐
[x]──┤ f ├─────[y]
     └───┘

blackbox dimensional area can be indicative of complexity theory

ℂ temporal complexity is represented by connectivity distance c̄ scale-ability ∧ variable speed
ℂ spacial complexity is represented by blackbox dimensions c̄ scale-ability

          ┌┐┌┐ 
     ┌───┐││││
[x]──┤ f ├┘│││┌[y]
     └───┘ ││││
           └┘└┘

we can use squiggly lines to save ℝ space 

ℝ space
ℝ time
ℂ space
ℂ time

          ┌┐┌┐ 
     ╔═══╗││││
[x]──╢ f ╟┘│││┌[y]
     ╚═══╝ ││││
           └┘└┘

since thickness is already being used for directionality
blackboxes can be double-lined

1]─╮
2]─┼───╌╌╌
3]─╯

type writers are a type of machine
cellular automata

time machine like time travelling debuggers
start, stop, loop/recurse, nth, interval notation [start,stop],..
arbitrary state manipulations

perl is good for text processing but i feel like this is a job for list processing in lisp
r-expressions versus l-expressions

the fourmost foremost productive programming language families based on scientific research papers and empirical evidence:
	‣ prolog   : language processing, language-based user interface, optimal exhaustive bruteforcing
	‣ perl     : text processing    , text-based user interface    , unix([one_liners, glue_code],[]).
	‣ lisp     : list processing    , metaprogramming              , prototyping
	‣ haskell  : multiprocessing    , formal methods               , lazy producer-consumer heuristics
…
	‣ smalltalk:                    , graphical user interface     ,

smalltalk may be a productive language but my opinions of object-oriented have changed:
	‣ object-oriented programming: based on the ℝ world; ℝ is mathematically imperfect
	‣ literate programming       : based on ℕ languages; ℕ languages are informal

smalltalk may be good for new programmers who can relate c̄ ℝ; unless they have a mathematical background, or are technically inclined
https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html

if you attempt to compile english you get compilation exceptions; there are "weird" words that break the rule of ib4e

haskell is a gateway to formal methods
prolog is a gateway to formal methods; inconsistency,..

formal methods are just ways of migrating/luring/serenading/seducing/.. bugs into a corner and declaring this is where we must tread carefully for we may step on one over here and that would be an ethical disaster

extreme types of formal methods:
	‣ formal verification of implementation against a formal specification
	‣ theorem proving
weakest types of formal methods:
	‣ haskell
all else is informal

unsafe languages:
	‣ lisp
	‣ prolog
	‣ perl; strict pragmas add safety but i do not use perl for safety, in fact i use perl because of the inherent lack of safety
red tape safety nets gets in the way; have you ever tried training wheels?
cut across the lawn versus walking on the winding footpath; edward scissor-hands style

toys and other playful languages:
	‣ prolog is like playing c̄ shape sorters; you can put "-thing"s anywhere, and even all at the same time!
	‣ haskell is like playing c̄ magnets; some"-thing"s just willn't goto gether!
	‣ pythonic pseudocode is like playing c̄ large/loud/obnoxious/clumsy wooden letter blocks; why does pseudocode enforce so many cosmetic rules?
	‣ assembly is like playing c̄ lego; especially stepping them!
	‣ smalltalk is like playing c̄ barbie dolls…

sexual innuendos:
	‣ prolog is like gang banging
