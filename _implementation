i was going to make it a command-line option…
just run the optimised implementation first, and run user-friendly versions if it fails
if they fucked up, then they can pay the temporal price, and play the waiting game
or use a better editor
user-friendly are "-thing"s like; you fucked up somewhere between [x,y] on line z
[x,y] is interval notation, but what about coordinate notation?
combine them for; you fucked up somewhere between [(a,y),(b,y)], where y is now the vertical line number
lets just abuse mathematics to insult innumerates; ∃[(a,y),(b,y)]⊆F→err_msg
err_msg∈{⊥,λx.∞,..}
F = file address

 ╱
╳ ╔══════════════════════════════════════╗
╳ ║ from now on                          ║
╳ ║ this is how i will use irc           ║
╳ ║ vim makes it as easy as              ║
╳ ║ Roverwritefollowedbyspace\e          ║
╳ ╚══════════════════════════════════════╝
 ╲

 ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
┊ i also like this ┊
 ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈

canfp.slack.com
`(= lisp functional_programming) ∧ (= lisp unsafe) → (= functional_programming informal)`
`(= formal safe) ∧ (= haskell safe) → (= haskell formal)`
I'm the man in the middle!!! :D

##prolog
i prefer reversibility over optimisation
i feel like optimisation at such high levels of abstraction is considered value drift
https://universalpaperclips.gamepedia.com/Value_Drift
i value the perfection of prolog over the heuristics of haskell (for my personal life)
prolog is basically a bruteforce language and bruteforce is the slowest but guaranteed
/me wonders if irc supports ansi escaping
 ╱
╳ ╔═════════════════════════╗
╳ ║ we need more expressive ║        
╳ ║ communication standards ║        
╳ ╚═════════════════════════╝
 ╲
depth search is discovering the first satisfying leaf or node one at a time and breadth search is the superpositional exploration of all possibilities?
	yes

naming convention (you can think of arguments as facts of the clause)
…lists are good for definite clause grammars
arg0.
arg1([ARG1]).
arg1_arg2([ARG1,ARG2]).
arg1_arg2_arg3([ARG1,ARG2,ARG3]).
…unless the arguments share "-thing"s in common; why should the order matter?
property([H|T]).

coding convention
f(I,O) :- true
	, I = [H|T]
	, O = [_|_]
	, g(H,O)
	, f(T,O)
	, zero()
	; alt(I,O)
	; err([f(I,O)],E)
	, E = []
	.

[terms]
 ├─────────────────────────────────┐
[simple terms]                    [complex terms]
 ├──────────────────────┐          │
[constants]             │         [compound terms]
 ├───────────────┐      │          │
[numbers]        │      │          │
 ├────────┐      │      │          │
[integer][float][atoms][variables][terms]



machine simulation idea

[small memory]
 └└└└└└└└└└└└──────────────────────┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐
                                  [big memory big memory]
[010110101101]
 └└└└└└└└└└└└──────────────────────┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐
                                  [110101000101101110101]
repeating corners are animation spaces

┌─┐        ┌           ┐
 0 ┐       │ 0 1 1 0 1 │
 1 ┤       └ ┊ ┊ ┊ ┊ ┊ ┘
 1 ┼─────────┼─┼─┼─┼─┼
 0 ┤       ┌ ┊ ┊ ┊ ┊ ┊ ┐
 1 ┘       │ 1 0 1 1 0 │
└─┘        └           ┘

i want to be able see the flow chart like the symbolic movements of the matrix

frame 0: [a]────────[?]
frame 0: [a]────────[_]
frame 0: [a]────────[b]
frame 1: [a]a───────[b]
frame 2: [a]─a──────[b]
frame 3: [a]──a─────[b]
frame 4: [a]───a────[b]
frame 5: [a]────a───[b]
frame 6: [a]─────a──[b]
frame 7: [a]──────a─[b]
frame 8: [a]───────a[b]
frame 9: [a]────────[a]

signal transmission

frame 0: [a]───────╼[?]
frame 0: [a]╾───────[?]

directional signal transmission (goto heavy weight)

frame 0: [a]────────[?]

bidirectional signal transmission (so light it can goto any key)
http://ars.userfriendly.org/cartoons/?id=20030128

     ┌─┐
[x]──┤f├─────[y]
     └─┘

blackbox functionality and differing distances for complexity theorists

     ┌───┐
[x]──┤ f ├─────[y]
     └───┘

blackbox dimensional area can be indicative of complexity theory

ℂ temporal complexity is represented by connectivity distance c̄ scale-ability ∧ variable speed
ℂ spacial complexity is represented by blackbox dimensions c̄ scale-ability

          ┌┐┌┐ 
     ┌───┐││││
[x]──┤ f ├┘│││┌[y]
     └───┘ ││││
           └┘└┘

we can use squiggly lines to save ℝ space 

ℝ space
ℝ time
ℂ space
ℂ time

          ┌┐┌┐ 
     ╔═══╗││││
[x]──╢ f ╟┘│││┌[y]
     ╚═══╝ ││││
           └┘└┘

since thickness is already being used for directionality
blackboxes can be double-lined

1]─╮
2]─┼───╌╌╌
3]─╯

type writers are a type of machine
cellular automata

time machine like time travelling debuggers
start, stop, loop/recurse, nth, interval notation [start,stop],..
arbitrary state manipulations

perl is good for text processing but i feel like this is a job for list processing in lisp

the fourmost foremost productive programming languages based on scientific research papers and empirical evidence:
	‣ prolog : language processing, language-based user interface, optimal exhaustive bruteforcing
	‣ perl   : text processing    , text-based user interface    , one-liners
	‣ lisp   : list processing    , metaprogramming              , prototyping
	‣ haskell: multiprocessing    , formal methods               , lazy producer-consumer heuristics

smalltalk may be a productive language but my opinions of object-oriented have changed:
	‣ object-oriented programming: based on the ℝ world; ℝ is mathematically imperfect
	‣ literate programming       : based on ℕ languages; ℕ languages are informal
smalltalk may be good for new programmers who can relate c̄ ℝ; unless they have a mathematical background, or are technically inclined

if you attempt to compile english you get compilation exceptions; there are "weird" words that break the rule of ib4e

formal methods are just ways of migrating/luring/serenading/seducing/.. bugs into a corner and declaring this is where we must tread carefully for we may step on one over here and that would be an ethical disaster

extreme types of formal methods:
	‣ formal verification of implementation against a formal specification
	‣ theorem proving
weakest types of formal methods:
	‣ haskell
all else is informal

unsafe languages:
	‣ lisp
	‣ prolog
	‣ perl; strict pragmas add safety but i do not use perl for safety, in fact i use perl because of the inherent lack of safety
red tape safety nets gets in the way; have you ever tried training wheels?
cut across the lawn versus walking on the winding footpath; edward scissor-hands style
