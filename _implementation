i was going to make it a command-line option…
just run the optimised implementation first, and run user-friendly versions if it fails
if they fucked up, then they can pay the temporal price, and play the waiting game
or use a better editor
user-friendly are "-thing"s like; you fucked up somewhere between [x,y] on line z
[x,y] is interval notation, but what about coordinate notation?
combine them for; you fucked up somewhere between [(a,y),(b,y)], where y is now the vertical line number
lets just abuse mathematics to insult innumerates; ∃[(a,y),(b,y)]⊆F→err_msg
err_msg∈{⊥,λx.∞,..}
F = file address

use vim for syntactic highlights
#!/usr/bin/env swipl
/*
i want _ or you give me _ versus i give you _ or you want _
\\ = prompt
\l = listen (this is for imparting knowledge and chatbot use for querying to resolve conflicts,..)
\m = metaprogramming (this is for chatbot self-resolution; every interaction will indicate some quantity of unresolved queries)
\q = query
\a = answer
\e = escape or end
@_ chatbot is communicating
@s shyam is communicating

$# i want _ or you give me _
$chatbot
1
\q
@_ What is your name?
@s my name is shyam
0
\a
@s what is my name
@_ Your name is Shyam.
0
\l
@s 42 is the ultimate answer to life, the universe, and everything
∞
\e

$# i give you _ or  you want _
$chatbot
1
\a
@_ What is your name?
@s my name is shyam
0
\q
@s what is my name
@_ Your name is Shyam.
0
\l
@s 42 is the ultimate answer to life, the universe, and everything
∞
\e

greetings and smalltalk are wastes of time
hith is knowingly aware someone is there
"Who are you?" should be the first intelligent query per session (between $chatbot and \e)
hith should remember
so if my name is shyam
hith will remember me as shyam the 1ˢᵗ!!! :D
and the preceding queries will attempt to remove any proof theoretic doubt
"Have you communicated with me before?" → yes
"What is your name?" → shyam has your anomaly mitigated
"What is your age?" → 0b11101, 0x1d,..
"what is your gender?" → i am the man who knows every"-thing"
"Which country is your point of origin?" → i come from the land down under where we criminally celebrate cop killers like the kelly gang
"Will you marry me?" → i need; 100pts of id, blood/fluid test, background check, consent form, death/injury waiver; no meat, no drugs, no tobacco, no alcohol, no caffeine; …

answers must be boolean assumed truths and unknowns
to know, or not to know, that is the query
but they may be false in ℝ
so in ℂ they are boolean while in ℝ they are trilean
*/

 ╱
╳ ╔══════════════════════════════════════╗
╳ ║ from now on                          ║
╳ ║ this is how i will use irc           ║
╳ ║ vim makes it as easy as              ║
╳ ║ Roverwritefollowedbyspace\e          ║
╳ ╚══════════════════════════════════════╝
 ╲

 ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
┊ i also like this ┊
 ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈

canfp.slack.com
`(= lisp functional_programming) ∧ (= lisp unsafe) → (= functional_programming informal)`
`(= formal safe) ∧ (= haskell safe) → (= haskell formal)`
I'm the man in the middle!!! :D

##prolog
i prefer reversibility over optimisation
i feel like optimisation at such high levels of abstraction is considered value drift
https://universalpaperclips.gamepedia.com/Value_Drift
i value the perfection of prolog over the heuristics of haskell
for my personal life
prolog is basically a bruteforce language and bruteforce is the slowest but guaranteed
/me wonders if irc supports ansi escaping
 ╱
╳ ╔═════════════════════════╗
╳ ║ we need more expressive ║        
╳ ║ communication standards ║        
╳ ╚═════════════════════════╝
 ╲
depth search is discovering the first satisfying leaf or node one at a time and breadth search is the superpositional exploration of all possibilities?
	yes
/me wonders if this is what everyone means when they say they are doing time or they did their time
/me never wants to do time ever again after this
/me thinks if douglas lenat solved an unsolved problem it would prove cyc is more than just a defence contract scam
https://en.wikipedia.org/wiki/Cyc#Criticisms
should an intelligence be supported by tools or expected to design and implement their own?
guided versus misguided versus unguided
i have seen no evidence since cyc has yet to solve any problem unsolved by alternatives
as a thought experiment if you are in a room and are receiving symbols it is impossible to derive some pattern recognition without context since we learn by relating reality to symbolic contexts
https://en.wikipedia.org/wiki/Chinese_room
this means whorfianism is a fallacious falsidical
even if you hook up cameras and microphones and robotic limbs the system is processing all the data in the same way
biological brains are dysfunctional in that they lack referential transparency in their data processing systems otherwise we would have an understanding of their complexities
it is not like they have a consistent arithmetic and logic unit
c = (λ÷2)×(1-(λ÷2))
https://rationalwiki.org/wiki/Polymeric_falcighol_derivation
cyc cannot solve it

/me has awoken with a plan to refactor time into an elegant implementation
/me has discovered how to do time the prolog way
/me has discovered the prolog way is unsatisfactory for their purposes
/me thinks they have found a bug
?- findall(Y, (between(0,2000,Y), 0 is Y mod 100, day_of_the_year(date(Y,12,31),366)), L)
https://en.wikipedia.org/wiki/Leap_year#Gregorian_calendar
For example, the years 1700, 1800, and 1900 are not leap years, but the year 2000 is.[5]
/me crashed and the last message they logged was at 01:40 < ardin_agoy> For example, the years 1700, 1800, and 1900 are not leap years, but the year 2000 is.[5]
/me is submitting the bug
/me submitted their first bug at https://github.com/SWI-Prolog/issues/issues/80
/me is renaming themsalves
/me is renaming themselves
halt.
/me does not know why that happens
/me should have done this first https://github.com/SWI-Prolog/issues/issues?utf8=%E2%9C%93&q=leap+year
/me thinks they found another bug
/me was attempting to edit http://www.swi-prolog.org/bug.html
http://www.swi-prolog.org/wiki_edit?location=/bug.html
that is an internal server error
/me does not know how to report this bug
/me submitted their second bug at https://github.com/SWI-Prolog/issues/issues/81
i am not fluent in any language
i have been language hopping and decided to get fluent at prolog and try to use it every single day for the rest of my life
well prolog family anyway
i was thinking about using prolog for everything
my goal for 2019 is to get fluent at prolog and write a planner to optimise my life for productivity
2020 is perl and 2021 is lisp and 2022 is haskell
but if i satisfy my linguistic goals early then everything will shift
well the billion dollar fortnite is more popular than roblox
i think popularity contests like alexa ranking is a good place to learn 5w of success
wikipedia and wayback machine do fundraising based on donations
ubuntu download page has a slider thing like the humble bundle
https://en.wikipedia.org/wiki/Business_models_for_open-source_software
euclideon got a 2 million dollar grant from the australian government
https://en.wikipedia.org/wiki/Euclideon
fortnite shares their profits with content creators
chatbots make them redundant
vsauce had an episode on it
there was a guy dating an npc
https://www.youtube.com/watch?v=qZXpgf8N6hs
i think it was that one
i am interested in formally verified malware
to defend oneself one must be knowledgeable of offences
governments are compromising firmware
the ultimate query is how do you know if you have been compromised?
if your hardware io is being split then they can monitor you without your knowledge
is this about the european union and their gdpr ddos?
they spammed my inbox like a million times
larkc was sold to them as well?
floss is good software
free libre open source software
i just floss daily
_: there exists ethical malware https://github.com/kanaka/mal
https://rosettacode.org/wiki/Program_name
i would prefer to be ignorant of the low level to avoid value drift
/me just figured out that X = f(X) is recursion
well X=f(X),X. with f(X):-f(X). in the basement
has bucketed 6 prolog books and tutorials
yes
in my bucket
catching each and every drop of knowledge acquisition

naming convention (you can think of arguments as facts of the clause)
…lists are good for definite clause grammars
…lists are good for F(X) instead of F(A), F(A,B), F(A,B,C),..
'arg 0'([[],[]]).
'arg 1'([[ARG1],[]]).
'arg 1, arg 2'([[ARG1, ARG2],[]]).
'arg 1, arg 2, arg 3'([[ARG1, ARG2, ARG3],[]]).
…unless the arguments share "-thing"s in common; why should the order matter?
property([[H|T], []]).
commonality([[H|T], []]).

coding convention
f --> {true}
	, a
	, b
	, c
	; x
	, y
	, z
	.
f([I,O]) :- true
	, I = [H|T]
	, O = [_|_]
	, I = Q
	, O = A
	, g([H, O])
	, f([T, O])
	, ( true
		, zero([[],[]])
		; alt([I, O])
	)
	; err([[f([I, O])], E])
	, E = []
	.

knowledge base systems

%propositional_knowledge_base
'i have a lot of junk'.
'i do not have a job'.

%royal_knowledge_base
'i am dieting'.
'i am exercising'.
'i am getting healthy' :- 'i am dieting', 'i am exercising'.
'i am getting unhealthy' :- 'i am not dieting'; 'i am not exercising'.

%factual_knowledge_base
recipe(['thrown vegvit multivitamin']).
recipe(['peeled fresh orange']).
recipe(['peeled fresh banana']).
recipe(['peeled fresh avocado']).
recipe(['spreaded bread']).
recipe(['serialised vegan milk']).
recipe([
	'stirred rice cooker'
	, 'purified water filter'
	, 'bubbling water kettle'
	, 'poured flaxseed oil'
	, 'torn fresh chilli'
	, 'tipped cup of rice'
	, 'circumfused can of tomato dye'
	, 'spilled can of corn kernels'
	, 'decanted can of red kidney beans'
	, 'sprinkled iodised salt'
	, 'spouted water'
	, 'scraped fresh avocado'
]).
recipe([
	'stirred rice cooker'
	, 'purified water filter'
	, 'bubbling water kettle'
	, 'poured flaxseed oil'
	, 'torn fresh chilli'
	, 'tipped cup of rice'
	, 'circumfused can of tomato dye'
	, 'spilled can of corn kernels'
	, 'decanted can of red kidney beans'
	, 'sprinkled iodised salt'
	, 'spouted water'
	, 'tossed vegan cheese'
	, 'scraped fresh avocado'
	, 'spooned vegan sour cream'
]).

%tabular_knowledge_base
tab1(X) :- findall(E, row1(E), X).
row1(X) :- X = col1_col2_col3_col4_col5(_), X.
col1_col2_col3_col4_col5([COL1, COL2, COL3, COL4, COL5]).

dcg rules

a --> true

get --> [X], {f(X)}.
f --> [X], {g(X)}.
f --> [H|T], {h(H),t(T)}.
f --> L, {lisp(L)}.
f --> [A,B,C], {google([A,B,C])}.

% a plan is basically just a list of things to do

% foreflow/backflow
f(Y) -> [X], {f(X,Y)}. % f/3 --> f/2
% backflow/foreflow
f --> [X], {f(X)}. % f/2 --> f/1

homoiconic graph theory

[terms]
 ├─────────────────────────────────┐
[simple terms]                    [complex terms]
 ├──────────────────────┐          │
[constants]             │         [compound terms]
 ├───────────────┐      │          │
[numbers]        │      │          │
 ├────────┐      │      │          │
[integer][float][atoms][variables][terms]

machine simulation idea

[small memory]
 └└└└└└└└└└└└──────────────────────┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐
                                  [big memory big memory]
[010110101101]
 └└└└└└└└└└└└──────────────────────┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐
                                  [110101000101101110101]

repeating corners are animation spaces

┌─┐        ┌           ┐
 0 ┐       │ 0 1 1 0 1 │
 1 ┤       └ ┊ ┊ ┊ ┊ ┊ ┘
 1 ┼─────────┼─┼─┼─┼─┼
 0 ┤       ┌ ┊ ┊ ┊ ┊ ┊ ┐
 1 ┘       │ 1 0 1 1 0 │
└─┘        └           ┘

i want to be able see the flow chart like the symbolic movements of the matrix

frame 0: [a]────────[?]
frame 0: [a]────────[_]
frame 0: [a]────────[b]
frame 1: [a]a───────[b]
frame 2: [a]─a──────[b]
frame 3: [a]──a─────[b]
frame 4: [a]───a────[b]
frame 5: [a]────a───[b]
frame 6: [a]─────a──[b]
frame 7: [a]──────a─[b]
frame 8: [a]───────a[b]
frame 9: [a]────────[a]

signal transmission

frame 0: [a]───────╼[?]
frame 0: [a]╾───────[?]

directional signal transmission (goto heavy weight)

frame 0: [a]────────[?]

bidirectional signal transmission (so light it can goto any key)
http://ars.userfriendly.org/cartoons/?id=20030128

     ┌─┐
[x]──┤f├─────[y]
     └─┘

blackbox functionality and differing distances for complexity theorists

     ┌───┐
[x]──┤ f ├─────[y]
     └───┘

blackbox dimensional area can be indicative of complexity theory

ℂ temporal complexity is represented by connectivity distance c̄ scale-ability ∧ variable speed
ℂ spacial complexity is represented by blackbox dimensions c̄ scale-ability

          ┌┐┌┐ 
     ┌───┐││││
[x]──┤ f ├┘│││┌[y]
     └───┘ ││││
           └┘└┘

we can use squiggly lines to save ℝ space 

ℝ space
ℝ time
ℂ space
ℂ time

          ┌┐┌┐ 
     ╔═══╗││││
[x]──╢ f ╟┘│││┌[y]
     ╚═══╝ ││││
           └┘└┘

since thickness is already being used for directionality
blackboxes can be double-lined

1]─╮
2]─┼───╌╌╌
3]─╯

type writers are a type of machine
cellular automata

time machine like time travelling debuggers
start, stop, loop/recurse, nth, interval notation [start,stop],..
arbitrary state manipulations

perl is good for text processing but i feel like this is a job for list processing in lisp
r-expressions versus l-expressions

the fourmost foremost productive programming language families based on scientific research papers and empirical evidence:
	‣ prolog   : language processing, language-based user interface, optimal exhaustive bruteforcing
	‣ perl     : text processing    , text-based user interface    , unix([[one_liners, glue_code],[]]).
	‣ lisp     : list processing    , metaprogramming              , prototyping
	‣ haskell  : multiprocessing    , formal methods               , lazy producer-consumer heuristics
…
	‣ smalltalk:                    , graphical user interface     ,

smalltalk may be a productive language but my opinions of object-oriented have changed:
	‣ object-oriented programming: based on the ℝ world; ℝ is mathematically imperfect (bumblebees, the leaning tower of lire, brachistochrone,..)
	‣ literate programming       : based on ℕ languages; ℕ languages are informal

smalltalk may be good for new programmers who can relate c̄ ℝ; unless they have a mathematical background, or are technically inclined
https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html

if you attempt to compile english you get compilation exceptions; there are "weird" words that break the rule of ib4e

lisp is a gateway to formal methods; curry,..
prolog is a gateway to formal methods; mercury,..

formal methods are just ways of migrating/luring/serenading/seducing/.. bugs into a corner and declaring this is where we must tread carefully for we may step on one over here and that would be an ethical disaster

extreme types of formal methods:
	‣ formal verification of implementation against a formal specification
	‣ theorem proving
weakest types of formal methods:
	‣ haskell
all else is informal

unsafe languages:
	‣ lisp
	‣ prolog
	‣ perl; strict pragmas add safety but i do not use perl for safety, in fact i use perl because of the inherent lack of safety
red tape safety nets gets in the way; have you ever tried training wheels?
cut across the lawn versus walking on the winding footpath; edward scissor-hands style

toys and other playful languages:
	‣ prolog is like playing c̄ shape sorters; you can put "-thing"s anywhere, and even all at the same time!
	‣ haskell is like playing c̄ magnets; some"-thing"s just willn't goto gether!
	‣ pythonic pseudocode is like playing c̄ large/loud/obnoxious/clumsy wooden letter blocks; why does pseudocode enforce so many cosmetic rules?
	‣ assembly is like playing c̄ lego; especially stepping them!
	‣ smalltalk is like playing c̄ barbie dolls…

sexual innuendos:
	‣ prolog is like gang banging
