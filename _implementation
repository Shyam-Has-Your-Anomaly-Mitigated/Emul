i was going to make it a command-line option…
just run the optimised implementation first, and run user-friendly versions if it fails
if they fucked up, then they can pay the temporal price, and play the waiting game
or use a better editor
user-friendly are "-thing"s like; you fucked up somewhere between [x,y] on line z
[x,y] is interval notation, but what about coordinate notation?
combine them for; you fucked up somewhere between [(a,y),(b,y)], where y is now the vertical line number
lets just abuse mathematics to insult innumerates; ∃[(a,y),(b,y)]⊆F→err_msg
err_msg∈{⊥,λx.∞,..}
F = file address

 ╱
╳ ╔══════════════════════════════════════╗
╳ ║ from now on                          ║
╳ ║ this is how i will use irc           ║
╳ ║ vim makes it as easy as              ║
╳ ║ Roverwritefollowedbyspace\e          ║
╳ ╚══════════════════════════════════════╝
 ╲

 ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
┊ i also like this ┊
 ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈

##prolog
i prefer reversibility over optimisation
i feel like optimisation at such high levels of abstraction is considered value drift
https://universalpaperclips.gamepedia.com/Value_Drift
i value the perfection of prolog over the heuristics of haskell (for my personal life)
prolog is basically a bruteforce language and bruteforce is the slowest but guaranteed
/me wonders if irc supports ansi escaping
 ╱
╳ ╔═════════════════════════╗
╳ ║ we need more expressive ║        
╳ ║ communication standards ║        
╳ ╚═════════════════════════╝
 ╲

coding convention
f(I,O) :- true
	, I = [H|T]
	, O = [_|_]
	, g(H,O)
	, f(T,O)
	, zero()
	; alt(I,O)
	; err([f(I,O)],E)
	, E = []
	.

[terms]
 ├─────────────────────────────────┐
[simple terms]                    [complex terms]
 ├──────────────────────┐          │
[constants]             │         [compound terms]
 ├───────────────┐      │          │
[numbers]        │      │          │
 ├────────┐      │      │          │
[integer][float][atoms][variables][terms]



machine simulation idea

[small memory]
 └└└└└└└└└└└└──────────────────────┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐
                                  [big memory big memory]
[010110101101]
 └└└└└└└└└└└└──────────────────────┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐┐
                                  [110101000101101110101]
repeating corners are animation spaces

┌─┐        ┌           ┐
 0 ┐       │ 0 1 1 0 1 │
 1 ┤       └ ┊ ┊ ┊ ┊ ┊ ┘
 1 ┼─────────┼─┼─┼─┼─┼
 0 ┤       ┌ ┊ ┊ ┊ ┊ ┊ ┐
 1 ┘       │ 1 0 1 1 0 │
└─┘        └           ┘

i want to be able see the flow chart like the symbolic movements of the matrix

frame 0: [a]────────[?]
frame 0: [a]────────[_]
frame 0: [a]────────[b]
frame 1: [a]a───────[b]
frame 2: [a]─a──────[b]
frame 3: [a]──a─────[b]
frame 4: [a]───a────[b]
frame 5: [a]────a───[b]
frame 6: [a]─────a──[b]
frame 7: [a]──────a─[b]
frame 8: [a]───────a[b]
frame 9: [a]────────[a]

signal transmission

frame 0: [a]───────╼[?]
frame 0: [a]╾───────[?]

directional signal transmission (goto heavy weight)

frame 0: [a]────────[?]

bidirectional signal transmission (so light it can goto any key)
http://ars.userfriendly.org/cartoons/?id=20030128

     ┌─┐
[x]──┤f├─────[y]
     └─┘

blackbox functionality and differing distances for complexity theorists

     ┌───┐
[x]──┤ f ├─────[y]
     └───┘

blackbox dimensional area can be indicative of complexity theory

ℂ temporal complexity is represented by connectivity distance c̄ scale-ability ∧ variable speed
ℂ spacial complexity is represented by blackbox dimensions c̄ scale-ability

          ┌┐┌┐ 
     ┌───┐││││
[x]──┤ f ├┘│││┌[y]
     └───┘ ││││
           └┘└┘

we can use squiggly lines to save ℝ space 

ℝ space
ℝ time
ℂ space
ℂ time

          ┌┐┌┐ 
     ╔═══╗││││
[x]──╢ f ╟┘│││┌[y]
     ╚═══╝ ││││
           └┘└┘

since thickness is already being used for directionality
blackboxes can be double-lined
